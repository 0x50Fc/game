// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Value.proto

#ifndef PROTOBUF_Value_2eproto__INCLUDED
#define PROTOBUF_Value_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Value_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsValue_Vec4Impl();
void InitDefaultsValue_Vec4();
void InitDefaultsValue_Mat4x4Impl();
void InitDefaultsValue_Mat4x4();
void InitDefaultsValue_Vec3Impl();
void InitDefaultsValue_Vec3();
void InitDefaultsValue_Mat3x3Impl();
void InitDefaultsValue_Mat3x3();
void InitDefaultsValue_Vec2Impl();
void InitDefaultsValue_Vec2();
void InitDefaultsValue_Mat2x2Impl();
void InitDefaultsValue_Mat2x2();
void InitDefaultsValueImpl();
void InitDefaultsValue();
inline void InitDefaults() {
  InitDefaultsValue_Vec4();
  InitDefaultsValue_Mat4x4();
  InitDefaultsValue_Vec3();
  InitDefaultsValue_Mat3x3();
  InitDefaultsValue_Vec2();
  InitDefaultsValue_Mat2x2();
  InitDefaultsValue();
}
}  // namespace protobuf_Value_2eproto
namespace kk {
namespace proto {
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Value_Mat2x2;
class Value_Mat2x2DefaultTypeInternal;
extern Value_Mat2x2DefaultTypeInternal _Value_Mat2x2_default_instance_;
class Value_Mat3x3;
class Value_Mat3x3DefaultTypeInternal;
extern Value_Mat3x3DefaultTypeInternal _Value_Mat3x3_default_instance_;
class Value_Mat4x4;
class Value_Mat4x4DefaultTypeInternal;
extern Value_Mat4x4DefaultTypeInternal _Value_Mat4x4_default_instance_;
class Value_Vec2;
class Value_Vec2DefaultTypeInternal;
extern Value_Vec2DefaultTypeInternal _Value_Vec2_default_instance_;
class Value_Vec3;
class Value_Vec3DefaultTypeInternal;
extern Value_Vec3DefaultTypeInternal _Value_Vec3_default_instance_;
class Value_Vec4;
class Value_Vec4DefaultTypeInternal;
extern Value_Vec4DefaultTypeInternal _Value_Vec4_default_instance_;
}  // namespace proto
}  // namespace kk
namespace kk {
namespace proto {

// ===================================================================

class Value_Vec4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Vec4) */ {
 public:
  Value_Vec4();
  virtual ~Value_Vec4();

  Value_Vec4(const Value_Vec4& from);

  inline Value_Vec4& operator=(const Value_Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Vec4(Value_Vec4&& from) noexcept
    : Value_Vec4() {
    *this = ::std::move(from);
  }

  inline Value_Vec4& operator=(Value_Vec4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Vec4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Vec4* internal_default_instance() {
    return reinterpret_cast<const Value_Vec4*>(
               &_Value_Vec4_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Value_Vec4* other);
  friend void swap(Value_Vec4& a, Value_Vec4& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Vec4* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Vec4* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Vec4& from);
  void MergeFrom(const Value_Vec4& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Vec4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Vec4)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Vec4Impl();
};
// -------------------------------------------------------------------

class Value_Mat4x4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Mat4x4) */ {
 public:
  Value_Mat4x4();
  virtual ~Value_Mat4x4();

  Value_Mat4x4(const Value_Mat4x4& from);

  inline Value_Mat4x4& operator=(const Value_Mat4x4& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Mat4x4(Value_Mat4x4&& from) noexcept
    : Value_Mat4x4() {
    *this = ::std::move(from);
  }

  inline Value_Mat4x4& operator=(Value_Mat4x4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Mat4x4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Mat4x4* internal_default_instance() {
    return reinterpret_cast<const Value_Mat4x4*>(
               &_Value_Mat4x4_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Value_Mat4x4* other);
  friend void swap(Value_Mat4x4& a, Value_Mat4x4& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Mat4x4* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Mat4x4* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Mat4x4& from);
  void MergeFrom(const Value_Mat4x4& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Mat4x4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kk.proto.Value.Vec4 m0 = 1;
  bool has_m0() const;
  void clear_m0();
  static const int kM0FieldNumber = 1;
  const ::kk::proto::Value_Vec4& m0() const;
  ::kk::proto::Value_Vec4* release_m0();
  ::kk::proto::Value_Vec4* mutable_m0();
  void set_allocated_m0(::kk::proto::Value_Vec4* m0);

  // required .kk.proto.Value.Vec4 m1 = 2;
  bool has_m1() const;
  void clear_m1();
  static const int kM1FieldNumber = 2;
  const ::kk::proto::Value_Vec4& m1() const;
  ::kk::proto::Value_Vec4* release_m1();
  ::kk::proto::Value_Vec4* mutable_m1();
  void set_allocated_m1(::kk::proto::Value_Vec4* m1);

  // required .kk.proto.Value.Vec4 m2 = 3;
  bool has_m2() const;
  void clear_m2();
  static const int kM2FieldNumber = 3;
  const ::kk::proto::Value_Vec4& m2() const;
  ::kk::proto::Value_Vec4* release_m2();
  ::kk::proto::Value_Vec4* mutable_m2();
  void set_allocated_m2(::kk::proto::Value_Vec4* m2);

  // required .kk.proto.Value.Vec4 m4 = 4;
  bool has_m4() const;
  void clear_m4();
  static const int kM4FieldNumber = 4;
  const ::kk::proto::Value_Vec4& m4() const;
  ::kk::proto::Value_Vec4* release_m4();
  ::kk::proto::Value_Vec4* mutable_m4();
  void set_allocated_m4(::kk::proto::Value_Vec4* m4);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Mat4x4)
 private:
  void set_has_m0();
  void clear_has_m0();
  void set_has_m1();
  void clear_has_m1();
  void set_has_m2();
  void clear_has_m2();
  void set_has_m4();
  void clear_has_m4();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::kk::proto::Value_Vec4* m0_;
  ::kk::proto::Value_Vec4* m1_;
  ::kk::proto::Value_Vec4* m2_;
  ::kk::proto::Value_Vec4* m4_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Mat4x4Impl();
};
// -------------------------------------------------------------------

class Value_Vec3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Vec3) */ {
 public:
  Value_Vec3();
  virtual ~Value_Vec3();

  Value_Vec3(const Value_Vec3& from);

  inline Value_Vec3& operator=(const Value_Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Vec3(Value_Vec3&& from) noexcept
    : Value_Vec3() {
    *this = ::std::move(from);
  }

  inline Value_Vec3& operator=(Value_Vec3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Vec3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Vec3* internal_default_instance() {
    return reinterpret_cast<const Value_Vec3*>(
               &_Value_Vec3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Value_Vec3* other);
  friend void swap(Value_Vec3& a, Value_Vec3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Vec3* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Vec3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Vec3& from);
  void MergeFrom(const Value_Vec3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Vec3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Vec3)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Vec3Impl();
};
// -------------------------------------------------------------------

class Value_Mat3x3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Mat3x3) */ {
 public:
  Value_Mat3x3();
  virtual ~Value_Mat3x3();

  Value_Mat3x3(const Value_Mat3x3& from);

  inline Value_Mat3x3& operator=(const Value_Mat3x3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Mat3x3(Value_Mat3x3&& from) noexcept
    : Value_Mat3x3() {
    *this = ::std::move(from);
  }

  inline Value_Mat3x3& operator=(Value_Mat3x3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Mat3x3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Mat3x3* internal_default_instance() {
    return reinterpret_cast<const Value_Mat3x3*>(
               &_Value_Mat3x3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Value_Mat3x3* other);
  friend void swap(Value_Mat3x3& a, Value_Mat3x3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Mat3x3* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Mat3x3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Mat3x3& from);
  void MergeFrom(const Value_Mat3x3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Mat3x3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kk.proto.Value.Vec3 m0 = 1;
  bool has_m0() const;
  void clear_m0();
  static const int kM0FieldNumber = 1;
  const ::kk::proto::Value_Vec3& m0() const;
  ::kk::proto::Value_Vec3* release_m0();
  ::kk::proto::Value_Vec3* mutable_m0();
  void set_allocated_m0(::kk::proto::Value_Vec3* m0);

  // required .kk.proto.Value.Vec3 m1 = 2;
  bool has_m1() const;
  void clear_m1();
  static const int kM1FieldNumber = 2;
  const ::kk::proto::Value_Vec3& m1() const;
  ::kk::proto::Value_Vec3* release_m1();
  ::kk::proto::Value_Vec3* mutable_m1();
  void set_allocated_m1(::kk::proto::Value_Vec3* m1);

  // required .kk.proto.Value.Vec3 m2 = 3;
  bool has_m2() const;
  void clear_m2();
  static const int kM2FieldNumber = 3;
  const ::kk::proto::Value_Vec3& m2() const;
  ::kk::proto::Value_Vec3* release_m2();
  ::kk::proto::Value_Vec3* mutable_m2();
  void set_allocated_m2(::kk::proto::Value_Vec3* m2);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Mat3x3)
 private:
  void set_has_m0();
  void clear_has_m0();
  void set_has_m1();
  void clear_has_m1();
  void set_has_m2();
  void clear_has_m2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::kk::proto::Value_Vec3* m0_;
  ::kk::proto::Value_Vec3* m1_;
  ::kk::proto::Value_Vec3* m2_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Mat3x3Impl();
};
// -------------------------------------------------------------------

class Value_Vec2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Vec2) */ {
 public:
  Value_Vec2();
  virtual ~Value_Vec2();

  Value_Vec2(const Value_Vec2& from);

  inline Value_Vec2& operator=(const Value_Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Vec2(Value_Vec2&& from) noexcept
    : Value_Vec2() {
    *this = ::std::move(from);
  }

  inline Value_Vec2& operator=(Value_Vec2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Vec2* internal_default_instance() {
    return reinterpret_cast<const Value_Vec2*>(
               &_Value_Vec2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Value_Vec2* other);
  friend void swap(Value_Vec2& a, Value_Vec2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Vec2* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Vec2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Vec2& from);
  void MergeFrom(const Value_Vec2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Vec2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Vec2)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Vec2Impl();
};
// -------------------------------------------------------------------

class Value_Mat2x2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value.Mat2x2) */ {
 public:
  Value_Mat2x2();
  virtual ~Value_Mat2x2();

  Value_Mat2x2(const Value_Mat2x2& from);

  inline Value_Mat2x2& operator=(const Value_Mat2x2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Mat2x2(Value_Mat2x2&& from) noexcept
    : Value_Mat2x2() {
    *this = ::std::move(from);
  }

  inline Value_Mat2x2& operator=(Value_Mat2x2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Mat2x2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Mat2x2* internal_default_instance() {
    return reinterpret_cast<const Value_Mat2x2*>(
               &_Value_Mat2x2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Value_Mat2x2* other);
  friend void swap(Value_Mat2x2& a, Value_Mat2x2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Mat2x2* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Mat2x2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Mat2x2& from);
  void MergeFrom(const Value_Mat2x2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Mat2x2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kk.proto.Value.Vec2 m0 = 1;
  bool has_m0() const;
  void clear_m0();
  static const int kM0FieldNumber = 1;
  const ::kk::proto::Value_Vec2& m0() const;
  ::kk::proto::Value_Vec2* release_m0();
  ::kk::proto::Value_Vec2* mutable_m0();
  void set_allocated_m0(::kk::proto::Value_Vec2* m0);

  // required .kk.proto.Value.Vec2 m1 = 2;
  bool has_m1() const;
  void clear_m1();
  static const int kM1FieldNumber = 2;
  const ::kk::proto::Value_Vec2& m1() const;
  ::kk::proto::Value_Vec2* release_m1();
  ::kk::proto::Value_Vec2* mutable_m1();
  void set_allocated_m1(::kk::proto::Value_Vec2* m1);

  // @@protoc_insertion_point(class_scope:kk.proto.Value.Mat2x2)
 private:
  void set_has_m0();
  void clear_has_m0();
  void set_has_m1();
  void clear_has_m1();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::kk::proto::Value_Vec2* m0_;
  ::kk::proto::Value_Vec2* m1_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValue_Mat2x2Impl();
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kk.proto.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Value* other);
  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Value_Vec4 Vec4;
  typedef Value_Mat4x4 Mat4x4;
  typedef Value_Vec3 Vec3;
  typedef Value_Mat3x3 Mat3x3;
  typedef Value_Vec2 Vec2;
  typedef Value_Mat2x2 Mat2x2;

  // accessors -------------------------------------------------------

  // optional string string_value = 6;
  bool has_string_value() const;
  void clear_string_value();
  static const int kStringValueFieldNumber = 6;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // optional .kk.proto.Value.Vec4 vec4_value = 7;
  bool has_vec4_value() const;
  void clear_vec4_value();
  static const int kVec4ValueFieldNumber = 7;
  const ::kk::proto::Value_Vec4& vec4_value() const;
  ::kk::proto::Value_Vec4* release_vec4_value();
  ::kk::proto::Value_Vec4* mutable_vec4_value();
  void set_allocated_vec4_value(::kk::proto::Value_Vec4* vec4_value);

  // optional .kk.proto.Value.Mat4x4 mat4x4_value = 8;
  bool has_mat4x4_value() const;
  void clear_mat4x4_value();
  static const int kMat4X4ValueFieldNumber = 8;
  const ::kk::proto::Value_Mat4x4& mat4x4_value() const;
  ::kk::proto::Value_Mat4x4* release_mat4x4_value();
  ::kk::proto::Value_Mat4x4* mutable_mat4x4_value();
  void set_allocated_mat4x4_value(::kk::proto::Value_Mat4x4* mat4x4_value);

  // optional .kk.proto.Value.Vec3 vec3_value = 9;
  bool has_vec3_value() const;
  void clear_vec3_value();
  static const int kVec3ValueFieldNumber = 9;
  const ::kk::proto::Value_Vec3& vec3_value() const;
  ::kk::proto::Value_Vec3* release_vec3_value();
  ::kk::proto::Value_Vec3* mutable_vec3_value();
  void set_allocated_vec3_value(::kk::proto::Value_Vec3* vec3_value);

  // optional .kk.proto.Value.Mat3x3 mat3x3_value = 10;
  bool has_mat3x3_value() const;
  void clear_mat3x3_value();
  static const int kMat3X3ValueFieldNumber = 10;
  const ::kk::proto::Value_Mat3x3& mat3x3_value() const;
  ::kk::proto::Value_Mat3x3* release_mat3x3_value();
  ::kk::proto::Value_Mat3x3* mutable_mat3x3_value();
  void set_allocated_mat3x3_value(::kk::proto::Value_Mat3x3* mat3x3_value);

  // optional .kk.proto.Value.Vec2 vec2_value = 11;
  bool has_vec2_value() const;
  void clear_vec2_value();
  static const int kVec2ValueFieldNumber = 11;
  const ::kk::proto::Value_Vec2& vec2_value() const;
  ::kk::proto::Value_Vec2* release_vec2_value();
  ::kk::proto::Value_Vec2* mutable_vec2_value();
  void set_allocated_vec2_value(::kk::proto::Value_Vec2* vec2_value);

  // optional .kk.proto.Value.Mat2x2 mat2x2_value = 12;
  bool has_mat2x2_value() const;
  void clear_mat2x2_value();
  static const int kMat2X2ValueFieldNumber = 12;
  const ::kk::proto::Value_Mat2x2& mat2x2_value() const;
  ::kk::proto::Value_Mat2x2* release_mat2x2_value();
  ::kk::proto::Value_Mat2x2* mutable_mat2x2_value();
  void set_allocated_mat2x2_value(::kk::proto::Value_Mat2x2* mat2x2_value);

  // optional int64 int64_value = 2;
  bool has_int64_value() const;
  void clear_int64_value();
  static const int kInt64ValueFieldNumber = 2;
  ::google::protobuf::int64 int64_value() const;
  void set_int64_value(::google::protobuf::int64 value);

  // optional int32 int32_value = 1;
  bool has_int32_value() const;
  void clear_int32_value();
  static const int kInt32ValueFieldNumber = 1;
  ::google::protobuf::int32 int32_value() const;
  void set_int32_value(::google::protobuf::int32 value);

  // optional float float_value = 4;
  bool has_float_value() const;
  void clear_float_value();
  static const int kFloatValueFieldNumber = 4;
  float float_value() const;
  void set_float_value(float value);

  // optional double double_value = 3;
  bool has_double_value() const;
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 3;
  double double_value() const;
  void set_double_value(double value);

  // optional bool bool_value = 5;
  bool has_bool_value() const;
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 5;
  bool bool_value() const;
  void set_bool_value(bool value);

  // @@protoc_insertion_point(class_scope:kk.proto.Value)
 private:
  void set_has_int32_value();
  void clear_has_int32_value();
  void set_has_int64_value();
  void clear_has_int64_value();
  void set_has_double_value();
  void clear_has_double_value();
  void set_has_float_value();
  void clear_has_float_value();
  void set_has_bool_value();
  void clear_has_bool_value();
  void set_has_string_value();
  void clear_has_string_value();
  void set_has_vec4_value();
  void clear_has_vec4_value();
  void set_has_mat4x4_value();
  void clear_has_mat4x4_value();
  void set_has_vec3_value();
  void clear_has_vec3_value();
  void set_has_mat3x3_value();
  void clear_has_mat3x3_value();
  void set_has_vec2_value();
  void clear_has_vec2_value();
  void set_has_mat2x2_value();
  void clear_has_mat2x2_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr string_value_;
  ::kk::proto::Value_Vec4* vec4_value_;
  ::kk::proto::Value_Mat4x4* mat4x4_value_;
  ::kk::proto::Value_Vec3* vec3_value_;
  ::kk::proto::Value_Mat3x3* mat3x3_value_;
  ::kk::proto::Value_Vec2* vec2_value_;
  ::kk::proto::Value_Mat2x2* mat2x2_value_;
  ::google::protobuf::int64 int64_value_;
  ::google::protobuf::int32 int32_value_;
  float float_value_;
  double double_value_;
  bool bool_value_;
  friend struct ::protobuf_Value_2eproto::TableStruct;
  friend void ::protobuf_Value_2eproto::InitDefaultsValueImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Value_Vec4

// required float x = 1;
inline bool Value_Vec4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Vec4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Vec4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Vec4::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Value_Vec4::x() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec4.x)
  return x_;
}
inline void Value_Vec4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec4.x)
}

// required float y = 2;
inline bool Value_Vec4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Vec4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Vec4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Vec4::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Value_Vec4::y() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec4.y)
  return y_;
}
inline void Value_Vec4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec4.y)
}

// required float z = 3;
inline bool Value_Vec4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value_Vec4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value_Vec4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value_Vec4::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Value_Vec4::z() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec4.z)
  return z_;
}
inline void Value_Vec4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec4.z)
}

// required float w = 4;
inline bool Value_Vec4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value_Vec4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value_Vec4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value_Vec4::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Value_Vec4::w() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec4.w)
  return w_;
}
inline void Value_Vec4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec4.w)
}

// -------------------------------------------------------------------

// Value_Mat4x4

// required .kk.proto.Value.Vec4 m0 = 1;
inline bool Value_Mat4x4::has_m0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Mat4x4::set_has_m0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Mat4x4::clear_has_m0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Mat4x4::clear_m0() {
  if (m0_ != NULL) m0_->Clear();
  clear_has_m0();
}
inline const ::kk::proto::Value_Vec4& Value_Mat4x4::m0() const {
  const ::kk::proto::Value_Vec4* p = m0_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat4x4.m0)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec4*>(
      &::kk::proto::_Value_Vec4_default_instance_);
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::release_m0() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat4x4.m0)
  clear_has_m0();
  ::kk::proto::Value_Vec4* temp = m0_;
  m0_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::mutable_m0() {
  set_has_m0();
  if (m0_ == NULL) {
    m0_ = new ::kk::proto::Value_Vec4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat4x4.m0)
  return m0_;
}
inline void Value_Mat4x4::set_allocated_m0(::kk::proto::Value_Vec4* m0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m0_;
  }
  if (m0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m0, submessage_arena);
    }
    set_has_m0();
  } else {
    clear_has_m0();
  }
  m0_ = m0;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat4x4.m0)
}

// required .kk.proto.Value.Vec4 m1 = 2;
inline bool Value_Mat4x4::has_m1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Mat4x4::set_has_m1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Mat4x4::clear_has_m1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Mat4x4::clear_m1() {
  if (m1_ != NULL) m1_->Clear();
  clear_has_m1();
}
inline const ::kk::proto::Value_Vec4& Value_Mat4x4::m1() const {
  const ::kk::proto::Value_Vec4* p = m1_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat4x4.m1)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec4*>(
      &::kk::proto::_Value_Vec4_default_instance_);
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::release_m1() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat4x4.m1)
  clear_has_m1();
  ::kk::proto::Value_Vec4* temp = m1_;
  m1_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::mutable_m1() {
  set_has_m1();
  if (m1_ == NULL) {
    m1_ = new ::kk::proto::Value_Vec4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat4x4.m1)
  return m1_;
}
inline void Value_Mat4x4::set_allocated_m1(::kk::proto::Value_Vec4* m1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m1_;
  }
  if (m1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m1, submessage_arena);
    }
    set_has_m1();
  } else {
    clear_has_m1();
  }
  m1_ = m1;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat4x4.m1)
}

// required .kk.proto.Value.Vec4 m2 = 3;
inline bool Value_Mat4x4::has_m2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value_Mat4x4::set_has_m2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value_Mat4x4::clear_has_m2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value_Mat4x4::clear_m2() {
  if (m2_ != NULL) m2_->Clear();
  clear_has_m2();
}
inline const ::kk::proto::Value_Vec4& Value_Mat4x4::m2() const {
  const ::kk::proto::Value_Vec4* p = m2_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat4x4.m2)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec4*>(
      &::kk::proto::_Value_Vec4_default_instance_);
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::release_m2() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat4x4.m2)
  clear_has_m2();
  ::kk::proto::Value_Vec4* temp = m2_;
  m2_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::mutable_m2() {
  set_has_m2();
  if (m2_ == NULL) {
    m2_ = new ::kk::proto::Value_Vec4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat4x4.m2)
  return m2_;
}
inline void Value_Mat4x4::set_allocated_m2(::kk::proto::Value_Vec4* m2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m2_;
  }
  if (m2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m2, submessage_arena);
    }
    set_has_m2();
  } else {
    clear_has_m2();
  }
  m2_ = m2;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat4x4.m2)
}

// required .kk.proto.Value.Vec4 m4 = 4;
inline bool Value_Mat4x4::has_m4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value_Mat4x4::set_has_m4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value_Mat4x4::clear_has_m4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value_Mat4x4::clear_m4() {
  if (m4_ != NULL) m4_->Clear();
  clear_has_m4();
}
inline const ::kk::proto::Value_Vec4& Value_Mat4x4::m4() const {
  const ::kk::proto::Value_Vec4* p = m4_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat4x4.m4)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec4*>(
      &::kk::proto::_Value_Vec4_default_instance_);
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::release_m4() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat4x4.m4)
  clear_has_m4();
  ::kk::proto::Value_Vec4* temp = m4_;
  m4_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec4* Value_Mat4x4::mutable_m4() {
  set_has_m4();
  if (m4_ == NULL) {
    m4_ = new ::kk::proto::Value_Vec4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat4x4.m4)
  return m4_;
}
inline void Value_Mat4x4::set_allocated_m4(::kk::proto::Value_Vec4* m4) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m4_;
  }
  if (m4) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m4 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m4, submessage_arena);
    }
    set_has_m4();
  } else {
    clear_has_m4();
  }
  m4_ = m4;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat4x4.m4)
}

// -------------------------------------------------------------------

// Value_Vec3

// required float x = 1;
inline bool Value_Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Value_Vec3::x() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec3.x)
  return x_;
}
inline void Value_Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec3.x)
}

// required float y = 2;
inline bool Value_Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Value_Vec3::y() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec3.y)
  return y_;
}
inline void Value_Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec3.y)
}

// required float z = 3;
inline bool Value_Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value_Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value_Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value_Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Value_Vec3::z() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec3.z)
  return z_;
}
inline void Value_Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec3.z)
}

// -------------------------------------------------------------------

// Value_Mat3x3

// required .kk.proto.Value.Vec3 m0 = 1;
inline bool Value_Mat3x3::has_m0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Mat3x3::set_has_m0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Mat3x3::clear_has_m0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Mat3x3::clear_m0() {
  if (m0_ != NULL) m0_->Clear();
  clear_has_m0();
}
inline const ::kk::proto::Value_Vec3& Value_Mat3x3::m0() const {
  const ::kk::proto::Value_Vec3* p = m0_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat3x3.m0)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec3*>(
      &::kk::proto::_Value_Vec3_default_instance_);
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::release_m0() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat3x3.m0)
  clear_has_m0();
  ::kk::proto::Value_Vec3* temp = m0_;
  m0_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::mutable_m0() {
  set_has_m0();
  if (m0_ == NULL) {
    m0_ = new ::kk::proto::Value_Vec3;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat3x3.m0)
  return m0_;
}
inline void Value_Mat3x3::set_allocated_m0(::kk::proto::Value_Vec3* m0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m0_;
  }
  if (m0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m0, submessage_arena);
    }
    set_has_m0();
  } else {
    clear_has_m0();
  }
  m0_ = m0;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat3x3.m0)
}

// required .kk.proto.Value.Vec3 m1 = 2;
inline bool Value_Mat3x3::has_m1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Mat3x3::set_has_m1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Mat3x3::clear_has_m1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Mat3x3::clear_m1() {
  if (m1_ != NULL) m1_->Clear();
  clear_has_m1();
}
inline const ::kk::proto::Value_Vec3& Value_Mat3x3::m1() const {
  const ::kk::proto::Value_Vec3* p = m1_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat3x3.m1)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec3*>(
      &::kk::proto::_Value_Vec3_default_instance_);
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::release_m1() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat3x3.m1)
  clear_has_m1();
  ::kk::proto::Value_Vec3* temp = m1_;
  m1_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::mutable_m1() {
  set_has_m1();
  if (m1_ == NULL) {
    m1_ = new ::kk::proto::Value_Vec3;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat3x3.m1)
  return m1_;
}
inline void Value_Mat3x3::set_allocated_m1(::kk::proto::Value_Vec3* m1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m1_;
  }
  if (m1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m1, submessage_arena);
    }
    set_has_m1();
  } else {
    clear_has_m1();
  }
  m1_ = m1;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat3x3.m1)
}

// required .kk.proto.Value.Vec3 m2 = 3;
inline bool Value_Mat3x3::has_m2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value_Mat3x3::set_has_m2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value_Mat3x3::clear_has_m2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value_Mat3x3::clear_m2() {
  if (m2_ != NULL) m2_->Clear();
  clear_has_m2();
}
inline const ::kk::proto::Value_Vec3& Value_Mat3x3::m2() const {
  const ::kk::proto::Value_Vec3* p = m2_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat3x3.m2)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec3*>(
      &::kk::proto::_Value_Vec3_default_instance_);
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::release_m2() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat3x3.m2)
  clear_has_m2();
  ::kk::proto::Value_Vec3* temp = m2_;
  m2_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec3* Value_Mat3x3::mutable_m2() {
  set_has_m2();
  if (m2_ == NULL) {
    m2_ = new ::kk::proto::Value_Vec3;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat3x3.m2)
  return m2_;
}
inline void Value_Mat3x3::set_allocated_m2(::kk::proto::Value_Vec3* m2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m2_;
  }
  if (m2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m2, submessage_arena);
    }
    set_has_m2();
  } else {
    clear_has_m2();
  }
  m2_ = m2;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat3x3.m2)
}

// -------------------------------------------------------------------

// Value_Vec2

// required float x = 1;
inline bool Value_Vec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Vec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Vec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Vec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Value_Vec2::x() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec2.x)
  return x_;
}
inline void Value_Vec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec2.x)
}

// required float y = 2;
inline bool Value_Vec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Vec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Vec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Vec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Value_Vec2::y() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.Vec2.y)
  return y_;
}
inline void Value_Vec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.Vec2.y)
}

// -------------------------------------------------------------------

// Value_Mat2x2

// required .kk.proto.Value.Vec2 m0 = 1;
inline bool Value_Mat2x2::has_m0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Mat2x2::set_has_m0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Mat2x2::clear_has_m0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Mat2x2::clear_m0() {
  if (m0_ != NULL) m0_->Clear();
  clear_has_m0();
}
inline const ::kk::proto::Value_Vec2& Value_Mat2x2::m0() const {
  const ::kk::proto::Value_Vec2* p = m0_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat2x2.m0)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec2*>(
      &::kk::proto::_Value_Vec2_default_instance_);
}
inline ::kk::proto::Value_Vec2* Value_Mat2x2::release_m0() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat2x2.m0)
  clear_has_m0();
  ::kk::proto::Value_Vec2* temp = m0_;
  m0_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec2* Value_Mat2x2::mutable_m0() {
  set_has_m0();
  if (m0_ == NULL) {
    m0_ = new ::kk::proto::Value_Vec2;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat2x2.m0)
  return m0_;
}
inline void Value_Mat2x2::set_allocated_m0(::kk::proto::Value_Vec2* m0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m0_;
  }
  if (m0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m0, submessage_arena);
    }
    set_has_m0();
  } else {
    clear_has_m0();
  }
  m0_ = m0;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat2x2.m0)
}

// required .kk.proto.Value.Vec2 m1 = 2;
inline bool Value_Mat2x2::has_m1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Mat2x2::set_has_m1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Mat2x2::clear_has_m1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Mat2x2::clear_m1() {
  if (m1_ != NULL) m1_->Clear();
  clear_has_m1();
}
inline const ::kk::proto::Value_Vec2& Value_Mat2x2::m1() const {
  const ::kk::proto::Value_Vec2* p = m1_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.Mat2x2.m1)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec2*>(
      &::kk::proto::_Value_Vec2_default_instance_);
}
inline ::kk::proto::Value_Vec2* Value_Mat2x2::release_m1() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.Mat2x2.m1)
  clear_has_m1();
  ::kk::proto::Value_Vec2* temp = m1_;
  m1_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec2* Value_Mat2x2::mutable_m1() {
  set_has_m1();
  if (m1_ == NULL) {
    m1_ = new ::kk::proto::Value_Vec2;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.Mat2x2.m1)
  return m1_;
}
inline void Value_Mat2x2::set_allocated_m1(::kk::proto::Value_Vec2* m1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m1_;
  }
  if (m1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m1, submessage_arena);
    }
    set_has_m1();
  } else {
    clear_has_m1();
  }
  m1_ = m1;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.Mat2x2.m1)
}

// -------------------------------------------------------------------

// Value

// optional int32 int32_value = 1;
inline bool Value::has_int32_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Value::set_has_int32_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Value::clear_has_int32_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Value::clear_int32_value() {
  int32_value_ = 0;
  clear_has_int32_value();
}
inline ::google::protobuf::int32 Value::int32_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.int32_value)
  return int32_value_;
}
inline void Value::set_int32_value(::google::protobuf::int32 value) {
  set_has_int32_value();
  int32_value_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.int32_value)
}

// optional int64 int64_value = 2;
inline bool Value::has_int64_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Value::set_has_int64_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Value::clear_has_int64_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Value::clear_int64_value() {
  int64_value_ = GOOGLE_LONGLONG(0);
  clear_has_int64_value();
}
inline ::google::protobuf::int64 Value::int64_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.int64_value)
  return int64_value_;
}
inline void Value::set_int64_value(::google::protobuf::int64 value) {
  set_has_int64_value();
  int64_value_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.int64_value)
}

// optional double double_value = 3;
inline bool Value::has_double_value() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Value::set_has_double_value() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Value::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Value::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double Value::double_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.double_value)
  return double_value_;
}
inline void Value::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.double_value)
}

// optional float float_value = 4;
inline bool Value::has_float_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Value::set_has_float_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Value::clear_has_float_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Value::clear_float_value() {
  float_value_ = 0;
  clear_has_float_value();
}
inline float Value::float_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.float_value)
  return float_value_;
}
inline void Value::set_float_value(float value) {
  set_has_float_value();
  float_value_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.float_value)
}

// optional bool bool_value = 5;
inline bool Value::has_bool_value() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Value::set_has_bool_value() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Value::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Value::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool Value::bool_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.bool_value)
  return bool_value_;
}
inline void Value::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
  // @@protoc_insertion_point(field_set:kk.proto.Value.bool_value)
}

// optional string string_value = 6;
inline bool Value::has_string_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_string_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_string_value() {
  string_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_string_value();
}
inline const ::std::string& Value::string_value() const {
  // @@protoc_insertion_point(field_get:kk.proto.Value.string_value)
  return string_value_.GetNoArena();
}
inline void Value::set_string_value(const ::std::string& value) {
  set_has_string_value();
  string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kk.proto.Value.string_value)
}
#if LANG_CXX11
inline void Value::set_string_value(::std::string&& value) {
  set_has_string_value();
  string_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kk.proto.Value.string_value)
}
#endif
inline void Value::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_string_value();
  string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kk.proto.Value.string_value)
}
inline void Value::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kk.proto.Value.string_value)
}
inline ::std::string* Value::mutable_string_value() {
  set_has_string_value();
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.string_value)
  return string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_string_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.string_value)
  clear_has_string_value();
  return string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_string_value(::std::string* string_value) {
  if (string_value != NULL) {
    set_has_string_value();
  } else {
    clear_has_string_value();
  }
  string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string_value);
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.string_value)
}

// optional .kk.proto.Value.Vec4 vec4_value = 7;
inline bool Value::has_vec4_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_vec4_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_vec4_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_vec4_value() {
  if (vec4_value_ != NULL) vec4_value_->Clear();
  clear_has_vec4_value();
}
inline const ::kk::proto::Value_Vec4& Value::vec4_value() const {
  const ::kk::proto::Value_Vec4* p = vec4_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.vec4_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec4*>(
      &::kk::proto::_Value_Vec4_default_instance_);
}
inline ::kk::proto::Value_Vec4* Value::release_vec4_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.vec4_value)
  clear_has_vec4_value();
  ::kk::proto::Value_Vec4* temp = vec4_value_;
  vec4_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec4* Value::mutable_vec4_value() {
  set_has_vec4_value();
  if (vec4_value_ == NULL) {
    vec4_value_ = new ::kk::proto::Value_Vec4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.vec4_value)
  return vec4_value_;
}
inline void Value::set_allocated_vec4_value(::kk::proto::Value_Vec4* vec4_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vec4_value_;
  }
  if (vec4_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vec4_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vec4_value, submessage_arena);
    }
    set_has_vec4_value();
  } else {
    clear_has_vec4_value();
  }
  vec4_value_ = vec4_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.vec4_value)
}

// optional .kk.proto.Value.Mat4x4 mat4x4_value = 8;
inline bool Value::has_mat4x4_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_mat4x4_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_mat4x4_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_mat4x4_value() {
  if (mat4x4_value_ != NULL) mat4x4_value_->Clear();
  clear_has_mat4x4_value();
}
inline const ::kk::proto::Value_Mat4x4& Value::mat4x4_value() const {
  const ::kk::proto::Value_Mat4x4* p = mat4x4_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.mat4x4_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Mat4x4*>(
      &::kk::proto::_Value_Mat4x4_default_instance_);
}
inline ::kk::proto::Value_Mat4x4* Value::release_mat4x4_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.mat4x4_value)
  clear_has_mat4x4_value();
  ::kk::proto::Value_Mat4x4* temp = mat4x4_value_;
  mat4x4_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Mat4x4* Value::mutable_mat4x4_value() {
  set_has_mat4x4_value();
  if (mat4x4_value_ == NULL) {
    mat4x4_value_ = new ::kk::proto::Value_Mat4x4;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.mat4x4_value)
  return mat4x4_value_;
}
inline void Value::set_allocated_mat4x4_value(::kk::proto::Value_Mat4x4* mat4x4_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mat4x4_value_;
  }
  if (mat4x4_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mat4x4_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mat4x4_value, submessage_arena);
    }
    set_has_mat4x4_value();
  } else {
    clear_has_mat4x4_value();
  }
  mat4x4_value_ = mat4x4_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.mat4x4_value)
}

// optional .kk.proto.Value.Vec3 vec3_value = 9;
inline bool Value::has_vec3_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_vec3_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_vec3_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_vec3_value() {
  if (vec3_value_ != NULL) vec3_value_->Clear();
  clear_has_vec3_value();
}
inline const ::kk::proto::Value_Vec3& Value::vec3_value() const {
  const ::kk::proto::Value_Vec3* p = vec3_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.vec3_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec3*>(
      &::kk::proto::_Value_Vec3_default_instance_);
}
inline ::kk::proto::Value_Vec3* Value::release_vec3_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.vec3_value)
  clear_has_vec3_value();
  ::kk::proto::Value_Vec3* temp = vec3_value_;
  vec3_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec3* Value::mutable_vec3_value() {
  set_has_vec3_value();
  if (vec3_value_ == NULL) {
    vec3_value_ = new ::kk::proto::Value_Vec3;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.vec3_value)
  return vec3_value_;
}
inline void Value::set_allocated_vec3_value(::kk::proto::Value_Vec3* vec3_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vec3_value_;
  }
  if (vec3_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vec3_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vec3_value, submessage_arena);
    }
    set_has_vec3_value();
  } else {
    clear_has_vec3_value();
  }
  vec3_value_ = vec3_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.vec3_value)
}

// optional .kk.proto.Value.Mat3x3 mat3x3_value = 10;
inline bool Value::has_mat3x3_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_mat3x3_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_mat3x3_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_mat3x3_value() {
  if (mat3x3_value_ != NULL) mat3x3_value_->Clear();
  clear_has_mat3x3_value();
}
inline const ::kk::proto::Value_Mat3x3& Value::mat3x3_value() const {
  const ::kk::proto::Value_Mat3x3* p = mat3x3_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.mat3x3_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Mat3x3*>(
      &::kk::proto::_Value_Mat3x3_default_instance_);
}
inline ::kk::proto::Value_Mat3x3* Value::release_mat3x3_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.mat3x3_value)
  clear_has_mat3x3_value();
  ::kk::proto::Value_Mat3x3* temp = mat3x3_value_;
  mat3x3_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Mat3x3* Value::mutable_mat3x3_value() {
  set_has_mat3x3_value();
  if (mat3x3_value_ == NULL) {
    mat3x3_value_ = new ::kk::proto::Value_Mat3x3;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.mat3x3_value)
  return mat3x3_value_;
}
inline void Value::set_allocated_mat3x3_value(::kk::proto::Value_Mat3x3* mat3x3_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mat3x3_value_;
  }
  if (mat3x3_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mat3x3_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mat3x3_value, submessage_arena);
    }
    set_has_mat3x3_value();
  } else {
    clear_has_mat3x3_value();
  }
  mat3x3_value_ = mat3x3_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.mat3x3_value)
}

// optional .kk.proto.Value.Vec2 vec2_value = 11;
inline bool Value::has_vec2_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Value::set_has_vec2_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Value::clear_has_vec2_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Value::clear_vec2_value() {
  if (vec2_value_ != NULL) vec2_value_->Clear();
  clear_has_vec2_value();
}
inline const ::kk::proto::Value_Vec2& Value::vec2_value() const {
  const ::kk::proto::Value_Vec2* p = vec2_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.vec2_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Vec2*>(
      &::kk::proto::_Value_Vec2_default_instance_);
}
inline ::kk::proto::Value_Vec2* Value::release_vec2_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.vec2_value)
  clear_has_vec2_value();
  ::kk::proto::Value_Vec2* temp = vec2_value_;
  vec2_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Vec2* Value::mutable_vec2_value() {
  set_has_vec2_value();
  if (vec2_value_ == NULL) {
    vec2_value_ = new ::kk::proto::Value_Vec2;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.vec2_value)
  return vec2_value_;
}
inline void Value::set_allocated_vec2_value(::kk::proto::Value_Vec2* vec2_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vec2_value_;
  }
  if (vec2_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vec2_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vec2_value, submessage_arena);
    }
    set_has_vec2_value();
  } else {
    clear_has_vec2_value();
  }
  vec2_value_ = vec2_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.vec2_value)
}

// optional .kk.proto.Value.Mat2x2 mat2x2_value = 12;
inline bool Value::has_mat2x2_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Value::set_has_mat2x2_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Value::clear_has_mat2x2_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Value::clear_mat2x2_value() {
  if (mat2x2_value_ != NULL) mat2x2_value_->Clear();
  clear_has_mat2x2_value();
}
inline const ::kk::proto::Value_Mat2x2& Value::mat2x2_value() const {
  const ::kk::proto::Value_Mat2x2* p = mat2x2_value_;
  // @@protoc_insertion_point(field_get:kk.proto.Value.mat2x2_value)
  return p != NULL ? *p : *reinterpret_cast<const ::kk::proto::Value_Mat2x2*>(
      &::kk::proto::_Value_Mat2x2_default_instance_);
}
inline ::kk::proto::Value_Mat2x2* Value::release_mat2x2_value() {
  // @@protoc_insertion_point(field_release:kk.proto.Value.mat2x2_value)
  clear_has_mat2x2_value();
  ::kk::proto::Value_Mat2x2* temp = mat2x2_value_;
  mat2x2_value_ = NULL;
  return temp;
}
inline ::kk::proto::Value_Mat2x2* Value::mutable_mat2x2_value() {
  set_has_mat2x2_value();
  if (mat2x2_value_ == NULL) {
    mat2x2_value_ = new ::kk::proto::Value_Mat2x2;
  }
  // @@protoc_insertion_point(field_mutable:kk.proto.Value.mat2x2_value)
  return mat2x2_value_;
}
inline void Value::set_allocated_mat2x2_value(::kk::proto::Value_Mat2x2* mat2x2_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mat2x2_value_;
  }
  if (mat2x2_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mat2x2_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mat2x2_value, submessage_arena);
    }
    set_has_mat2x2_value();
  } else {
    clear_has_mat2x2_value();
  }
  mat2x2_value_ = mat2x2_value;
  // @@protoc_insertion_point(field_set_allocated:kk.proto.Value.mat2x2_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace kk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Value_2eproto__INCLUDED
